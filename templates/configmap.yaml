apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "freeradius.fullname" . }}
  labels:
    {{- include "freeradius.labels" . | nindent 4 }}
data:
  radiusd.conf: |
    # -*- text -*-
    ##
    ## radiusd.conf	-- FreeRADIUS server configuration file - 3.0.25
    ##
    ##	http://www.freeradius.org/
    ##	$Id: 70c0c32547eb6b68d6362430f66e27fc105fe2b2 $
    ##

    ######################################################################
    #
    #	The format of this (and other) configuration file is
    #	documented in "man unlang".  There are also READMEs in many
    #	subdirectories:
    #
    #	  raddb/README.rst
    #		How to upgrade from v2.
    #
    #	  raddb/mods-available/README.rst
    #		How to use mods-available / mods-enabled.
    #		All of the modules are in individual files,
    #		along with configuration items and full documentation.
    #
    #	  raddb/sites-available/README
    #		virtual servers, "listen" sections, clients, etc.
    #		The "sites-available" directory contains many
    #		worked examples of common configurations.
    #
    #	  raddb/certs/README.md
    #		How to create certificates for EAP or RadSec.
    #
    #	Every configuration item in the server is documented
    #	extensively in the comments in the example configuration
    #	files.
    #
    #	Before editing this (or any other) configuration file, PLEASE
    #	read "man radiusd".  See the section titled DEBUGGING.  It
    #	outlines a method where you can quickly create the
    #	configuration you want, with minimal effort.
    #
    #	Run the server in debugging mode, and READ the output.
    #
    #		$ radiusd -X
    #
    #	We cannot emphasize this point strongly enough.  The vast
    #	majority of problems can be solved by carefully reading the
    #	debugging output, which includes warnings about common issues,
    #	and suggestions for how they may be fixed.
    #
    #	There may be a lot of output, but look carefully for words like:
    #	"warning", "error", "reject", or "failure".  The messages there
    #	will usually be enough to guide you to a solution.
    #
    #	More documentation on "radiusd -X" is available on the wiki:
    #		https://wiki.freeradius.org/radiusd-X
    #
    #	If you are going to ask a question on the mailing list, then
    #	explain what you are trying to do, and include the output from
    #	debugging mode (radiusd -X).  Failure to do so means that all
    #	of the responses to your question will be people telling you
    #	to "post the output of radiusd -X".
    #
    #	Guidelines for posting to the mailing list are on the wiki:
    #		https://wiki.freeradius.org/list-help
    #
    #	Please read those guidelines before posting to the list.
    #
    #	Further documentation is available in the "doc" directory
    #	of the server distribution, or on the wiki at:
    #		https://wiki.freeradius.org/
    #
    #	New users to RADIUS should read the Technical Guide.  That guide
    #	explains how RADIUS works, how FreeRADIUS works, and what each
    #	part of a RADIUS system does.  It is not just "configure FreeRADIUS"!
    #		https://networkradius.com/doc/FreeRADIUS-Technical-Guide.pdf
    #
    #	More documentation on dictionaries, modules, unlang, etc. is also
    #	available on the Network RADIUS web site:
    #		https://networkradius.com/freeradius-documentation/
    #

    ######################################################################

    prefix = /usr
    exec_prefix = /usr
    sysconfdir = /etc
    localstatedir = /var
    sbindir = ${exec_prefix}/sbin
    logdir = /var/log/freeradius
    raddbdir = /etc/freeradius
    radacctdir = ${logdir}/radacct

    #
    #  name of the running server.  See also the "-n" command-line option.
    name = freeradius

    #  Location of config and logfiles.
    confdir = ${raddbdir}
    modconfdir = ${confdir}/mods-config
    certdir = ${confdir}/certs
    cadir   = ${confdir}/certs
    run_dir = ${localstatedir}/run/${name}

    # Should likely be ${localstatedir}/lib/radiusd
    db_dir = ${raddbdir}

    #
    # libdir: Where to find the rlm_* modules.
    #
    #   This should be automatically set at configuration time.
    #
    #   If the server builds and installs, but fails at execution time
    #   with an 'undefined symbol' error, then you can use the libdir
    #   directive to work around the problem.
    #
    #   The cause is usually that a library has been installed on your
    #   system in a place where the dynamic linker CANNOT find it.  When
    #   executing as root (or another user), your personal environment MAY
    #   be set up to allow the dynamic linker to find the library.  When
    #   executing as a daemon, FreeRADIUS MAY NOT have the same
    #   personalized configuration.
    #
    #   To work around the problem, find out which library contains that symbol,
    #   and add the directory containing that library to the end of 'libdir',
    #   with a colon separating the directory names.  NO spaces are allowed.
    #
    #   e.g. libdir = /usr/local/lib:/opt/package/lib
    #
    #   You can also try setting the LD_LIBRARY_PATH environment variable
    #   in a script which starts the server.
    #
    #   If that does not work, then you can re-configure and re-build the
    #   server to NOT use shared libraries, via:
    #
    #	./configure --disable-shared
    #	make
    #	make install
    #
    libdir = /usr/lib/freeradius

    #  pidfile: Where to place the PID of the RADIUS server.
    #
    #  The server may be signalled while it's running by using this
    #  file.
    #
    #  This file is written when ONLY running in daemon mode.
    #
    #  e.g.:  kill -HUP `cat /var/run/radiusd/radiusd.pid`
    #
    pidfile = ${run_dir}/${name}.pid

    #
    #  correct_escapes: use correct backslash escaping
    #
    #  Prior to version 3.0.5, the handling of backslashes was a little
    #  awkward, i.e. "wrong".  In some cases, to get one backslash into
    #  a regex, you had to put 4 in the config files.
    #
    #  Version 3.0.5 fixes that.  However, for backwards compatibility,
    #  the new method of escaping is DISABLED BY DEFAULT.  This means
    #  that upgrading to 3.0.5 won't break your configuration.
    #
    #  If you don't have double backslashes (i.e. \\) in your configuration,
    #  this won't matter to you.  If you do have them, fix that to use only
    #  one backslash, and then set "correct_escapes = true".
    #
    #  You can check for this by doing:
    #
    #	$ grep '\\\\' $(find raddb -type f -print)
    #
    correct_escapes = true

    #  panic_action: Command to execute if the server dies unexpectedly.
    #
    #  FOR PRODUCTION SYSTEMS, ACTIONS SHOULD ALWAYS EXIT.
    #  AN INTERACTIVE ACTION MEANS THE SERVER IS NOT RESPONDING TO REQUESTS.
    #  AN INTERACTICE ACTION MEANS THE SERVER WILL NOT RESTART.
    #
    #  THE SERVER MUST NOT BE ALLOWED EXECUTE UNTRUSTED PANIC ACTION CODE
    #  PATTACH CAN BE USED AS AN ATTACK VECTOR.
    #
    #  The panic action is a command which will be executed if the server
    #  receives a fatal, non user generated signal, i.e. SIGSEGV, SIGBUS,
    #  SIGABRT or SIGFPE.
    #
    #  This can be used to start an interactive debugging session so
    #  that information regarding the current state of the server can
    #  be acquired.
    #
    #  The following string substitutions are available:
    #  - %e   The currently executing program e.g. /sbin/radiusd
    #  - %p   The PID of the currently executing program e.g. 12345
    #
    #  Standard ${} substitutions are also allowed.
    #
    #  An example panic action for opening an interactive session in GDB would be:
    #
    #panic_action = "gdb %e %p"
    #
    #  Again, don't use that on a production system.
    #
    #  An example panic action for opening an automated session in GDB would be:
    #
    #panic_action = "gdb -silent -x ${raddbdir}/panic.gdb %e %p 2>&1 | tee ${logdir}/gdb-${name}-%p.log"
    #
    #  That command can be used on a production system.
    #

    #  max_request_time: The maximum time (in seconds) to handle a request.
    #
    #  Requests which take more time than this to process may be killed, and
    #  a REJECT message is returned.
    #
    #  WARNING: If you notice that requests take a long time to be handled,
    #  then this MAY INDICATE a bug in the server, in one of the modules
    #  used to handle a request, OR in your local configuration.
    #
    #  This problem is most often seen when using an SQL database.  If it takes
    #  more than a second or two to receive an answer from the SQL database,
    #  then it probably means that you haven't indexed the database.  See your
    #  SQL server documentation for more information.
    #
    #  Useful range of values: 5 to 120
    #
    max_request_time = {{ .Values.configuration.maxRequestTime }}

    #  cleanup_delay: The time to wait (in seconds) before cleaning up
    #  a reply which was sent to the NAS.
    #
    #  The RADIUS request is normally cached internally for a short period
    #  of time, after the reply is sent to the NAS.  The reply packet may be
    #  lost in the network, and the NAS will not see it.  The NAS will then
    #  re-send the request, and the server will respond quickly with the
    #  cached reply.
    #
    #  If this value is set too low, then duplicate requests from the NAS
    #  MAY NOT be detected, and will instead be handled as separate requests.
    #
    #  If this value is set too high, then the server will cache too many
    #  requests, and some new requests may get blocked.  (See 'max_requests'.)
    #
    #  Useful range of values: 2 to 30
    #
    cleanup_delay = {{ .Values.configuration.cleanupDelay }}

    #  max_requests: The maximum number of requests which the server keeps
    #  track of.  This should be 256 multiplied by the number of clients.
    #  e.g. With 4 clients, this number should be 1024.
    #
    #  If this number is too low, then when the server becomes busy,
    #  it will not respond to any new requests, until the 'cleanup_delay'
    #  time has passed, and it has removed the old requests.
    #
    #  If this number is set too high, then the server will use a bit more
    #  memory for no real benefit.
    #
    #  If you aren't sure what it should be set to, it's better to set it
    #  too high than too low.  Setting it to 1000 per client is probably
    #  the highest it should be.
    #
    #  Useful range of values: 256 to infinity
    #
    max_requests = {{ .Values.configuration.maxRequests }}

    #  hostname_lookups: Log the names of clients or just their IP addresses
    #  e.g., www.freeradius.org (on) or 206.47.27.232 (off).
    #
    #  The default is 'off' because it would be overall better for the net
    #  if people had to knowingly turn this feature on, since enabling it
    #  means that each client request will result in AT LEAST one lookup
    #  request to the nameserver.   Enabling hostname_lookups will also
    #  mean that your server may stop randomly for 30 seconds from time
    #  to time, if the DNS requests take too long.
    #
    #  Turning hostname lookups off also means that the server won't block
    #  for 30 seconds, if it sees an IP address which has no name associated
    #  with it.
    #
    #  allowed values: {no, yes}
    #
    hostname_lookups = {{ ternary "yes" "no" .Values.configuration.hostnameLookups }}

    #
    #  Run a "Post-Auth-Type Client-Lost" section.  This ONLY happens when
    #  the server sends an Access-Challenge, and then client does not
    #  respond to it.  The goal is to allow administrators to log
    #  something when the client does not respond.
    #
    #  See sites-available/default, "Post-Auth-Type Client-Lost" for more
    #  information.
    #
    #postauth_client_lost = no

    #
    #  Logging section.  The various "log_*" configuration items
    #  will eventually be moved here.
    #
    log {
    	#
    	#  Destination for log messages.  This can be one of:
    	#
    	#	files - log to "file", as defined below.
    	#	syslog - to syslog (see also the "syslog_facility", below.
    	#	stdout - standard output
    	#	stderr - standard error.
    	#
    	#  The command-line option "-X" over-rides this option, and forces
    	#  logging to go to stdout.
    	#
    	destination = {{ .Values.configuration.log.destination }}

    	#
    	#  Highlight important messages sent to stderr and stdout.
    	#
    	#  Option will be ignored (disabled) if output if TERM is not
    	#  an xterm or output is not to a TTY.
    	#
    	colourise = {{ ternary "yes" "no" .Values.configuration.log.colourise }}

    	#
    	#  The logging messages for the server are appended to the
    	#  tail of this file if destination == "files"
    	#
    	#  If the server is running in debugging mode, this file is
    	#  NOT used.
    	#
    	file = ${logdir}/radius.log

    	#
    	#  Which syslog facility to use, if ${destination} == "syslog"
    	#
    	#  The exact values permitted here are OS-dependent.  You probably
    	#  don't want to change this.
    	#
    	syslog_facility = daemon

    	#  Log the full User-Name attribute, as it was found in the request.
    	#
    	# allowed values: {no, yes}
    	#
    	stripped_names = {{ ternary "yes" "no" .Values.configuration.log.strippedNames }}

    	#  Log all (accept and reject) authentication results to the log file.
    	#
    	#  This is the same as setting "auth_accept = yes" and
    	#  "auth_reject = yes"
    	#
    	#  allowed values: {no, yes}
    	#
    	auth = no

    	#  Log Access-Accept results to the log file.
    	#
    	#  This is only used if "auth = no"
    	#
    	#  allowed values: {no, yes}
    	#
     	auth_accept = {{ ternary "yes" "no" .Values.configuration.log.authAccept }}

    	#  Log Access-Reject results to the log file.
    	#
    	#  This is only used if "auth = no"
    	#
    	#  allowed values: {no, yes}
    	#
     	auth_reject = {{ ternary "yes" "no" .Values.configuration.log.authReject }}

    	#  Log passwords with the authentication requests.
    	#  auth_badpass  - logs password if it's rejected
    	#  auth_goodpass - logs password if it's correct
    	#
    	#  allowed values: {no, yes}
    	#
    	auth_badpass = {{ ternary "yes" "no" .Values.configuration.log.authBadpass }}
    	auth_goodpass = {{ ternary "yes" "no" .Values.configuration.log.authGoodpass }}

    	#  Log additional text at the end of the "Login OK" messages.
    	#  for these to work, the "auth" and "auth_goodpass" or "auth_badpass"
    	#  configurations above have to be set to "yes".
    	#
    	#  The strings below are dynamically expanded, which means that
    	#  you can put anything you want in them.  However, note that
    	#  this expansion can be slow, and can negatively impact server
    	#  performance.
    	#
    #	msg_goodpass = ""
    #	msg_badpass = ""

    	#  The message when the user exceeds the Simultaneous-Use limit.
    	#
    	msg_denied = {{ .Values.configuration.log.msgDenied | quote }}

    	#  Suppress "secret" attributes when printing them in debug mode.
    	#
    	#  Secrets are NOT tracked across xlat expansions.  If your
    	#  configuration puts secrets into other strings, they will
    	#  still get printed.
    	#
    	#  Setting this to "yes" means that the server prints
    	#
    	#	<<< secret >>>
    	#
    	#  instead of the value, for attriburtes which contain secret
    	#  information.  e.g. User-Name, Tunnel-Password, etc.
    	#
    	#  This configuration is disabled by default.  It is extremely
    	#  important for administrators to be able to debug user logins
    	#  by seeing what is actually being sent.
    	#
     	suppress_secrets = {{ ternary "yes" "no" .Values.configuration.log.suppressSecrets }}
    }

    #  The program to execute to do concurrency checks.
    checkrad = ${sbindir}/checkrad

    #
    #  ENVIRONMENT VARIABLES
    #
    #  You can reference environment variables using an expansion like
    #  `$ENV{PATH}`.  However it is sometimes useful to be able to also set
    #  environment variables.  This section lets you do that.
    #
    #  The main purpose of this section is to allow administrators to keep
    #  RADIUS-specific configuration in the RADIUS configuration files.
    #  For example, if you need to set an environment variable which is
    #  used by a module.  You could put that variable into a shell script,
    #  but that's awkward.  Instead, just list it here.
    #
    #  Note that these environment variables are set AFTER the
    #  configuration file is loaded.  So you cannot set FOO here, and
    #  expect to reference it via `$ENV{FOO}` in another configuration file.
    #  You should instead just use a normal configuration variable for
    #  that.
    #
    ENV {
    	#
    	#  Set environment varable `FOO` to value '/bar/baz'.
    	#
    	#  NOTE: Note that you MUST use '='.  You CANNOT use '+=' to append
    	#  values.
    	#
    #	FOO = '/bar/baz'

    	#
    	#  Delete environment variable `BAR`.
    	#
    #	BAR

    	#
    	#  `LD_PRELOAD` is special.  It is normally set before the
    	#  application runs, and is interpreted by the dynamic linker.
    	#  Which means you cannot set it inside of an application, and
    	#  expect it to load libraries.
    	#
    	#  Since this functionality is useful, we extend it here.
    	#
    	#  You can set
    	#
    	#  LD_PRELOAD = /path/to/library.so
    	#
    	#  and the server will load the named libraries.  Multiple
    	#  libraries can be loaded by specificing multiple individual
    	#  `LD_PRELOAD` entries.
    	#
    	#
    #	LD_PRELOAD = /path/to/library1.so
    #	LD_PRELOAD = /path/to/library2.so
    }

    # SECURITY CONFIGURATION
    #
    #  There may be multiple methods of attacking on the server.  This
    #  section holds the configuration items which minimize the impact
    #  of those attacks
    #
    security {
    	#  chroot: directory where the server does "chroot".
    	#
    	#  The chroot is done very early in the process of starting
    	#  the server.  After the chroot has been performed it
    	#  switches to the "user" listed below (which MUST be
    	#  specified).  If "group" is specified, it switches to that
    	#  group, too.  Any other groups listed for the specified
    	#  "user" in "/etc/group" are also added as part of this
    	#  process.
    	#
    	#  The current working directory (chdir / cd) is left
    	#  *outside* of the chroot until all of the modules have been
    	#  initialized.  This allows the "raddb" directory to be left
    	#  outside of the chroot.  Once the modules have been
    	#  initialized, it does a "chdir" to ${logdir}.  This means
    	#  that it should be impossible to break out of the chroot.
    	#
    	#  If you are worried about security issues related to this
    	#  use of chdir, then simply ensure that the "raddb" directory
    	#  is inside of the chroot, end be sure to do "cd raddb"
    	#  BEFORE starting the server.
    	#
    	#  If the server is statically linked, then the only files
    	#  that have to exist in the chroot are ${run_dir} and
    	#  ${logdir}.  If you do the "cd raddb" as discussed above,
    	#  then the "raddb" directory has to be inside of the chroot
    	#  directory, too.
    	#
    #	chroot = /path/to/chroot/directory

    	# user/group: The name (or #number) of the user/group to run radiusd as.
    	#
    	#   If these are commented out, the server will run as the
    	#   user/group that started it.  In order to change to a
    	#   different user/group, you MUST be root ( or have root
    	#   privileges ) to start the server.
    	#
    	#   We STRONGLY recommend that you run the server with as few
    	#   permissions as possible.  That is, if you're not using
    	#   shadow passwords, the user and group items below should be
    	#   set to radius'.
    	#
    	#  NOTE that some kernels refuse to setgid(group) when the
    	#  value of (unsigned)group is above 60000; don't use group
    	#  "nobody" on these systems!
    	#
    	#  On systems with shadow passwords, you might have to set
    	#  'group = shadow' for the server to be able to read the
    	#  shadow password file.  If you can authenticate users while
    	#  in debug mode, but not in daemon mode, it may be that the
    	#  debugging mode server is running as a user that can read
    	#  the shadow info, and the user listed below can not.
    	#
    	#  The server will also try to use "initgroups" to read
    	#  /etc/groups.  It will join all groups where "user" is a
    	#  member.  This can allow for some finer-grained access
    	#  controls.
    	#
    	user = freerad
    	group = freerad

    	#  Core dumps are a bad thing.  This should only be set to
    	#  'yes' if you're debugging a problem with the server.
    	#
    	#  allowed values: {no, yes}
    	#
    	allow_core_dumps = no

    	#
    	#  max_attributes: The maximum number of attributes
    	#  permitted in a RADIUS packet.  Packets which have MORE
    	#  than this number of attributes in them will be dropped.
    	#
    	#  If this number is set too low, then no RADIUS packets
    	#  will be accepted.
    	#
    	#  If this number is set too high, then an attacker may be
    	#  able to send a small number of packets which will cause
    	#  the server to use all available memory on the machine.
    	#
    	#  Setting this number to 0 means "allow any number of attributes"
    	max_attributes = 200

    	#
    	#  reject_delay: When sending an Access-Reject, it can be
    	#  delayed for a few seconds.  This may help slow down a DoS
    	#  attack.  It also helps to slow down people trying to brute-force
    	#  crack a users password.
    	#
    	#  Setting this number to 0 means "send rejects immediately"
    	#
    	#  If this number is set higher than 'cleanup_delay', then the
    	#  rejects will be sent at 'cleanup_delay' time, when the request
    	#  is deleted from the internal cache of requests.
    	#
    	#  This number can be a decimal, e.g. 3.4
    	#
    	#  Useful ranges: 1 to 5
    	reject_delay = {{ .Values.configuration.security.rejectDelay }}

    	#
    	#  status_server: Whether or not the server will respond
    	#  to Status-Server requests.
    	#
    	#  When sent a Status-Server message, the server responds with
    	#  an Access-Accept or Accounting-Response packet.
    	#
    	#  This is mainly useful for administrators who want to "ping"
    	#  the server, without adding test users, or creating fake
    	#  accounting packets.
    	#
    	#  It's also useful when a NAS marks a RADIUS server "dead".
    	#  The NAS can periodically "ping" the server with a Status-Server
    	#  packet.  If the server responds, it must be alive, and the
    	#  NAS can start using it for real requests.
    	#
    	#  See also raddb/sites-available/status
    	#
    	status_server = {{ ternary "yes" "no" .Values.configuration.security.statusServer }}


    }

    # PROXY CONFIGURATION
    #
    #  proxy_requests: Turns proxying of RADIUS requests on or off.
    #
    #  The server has proxying turned on by default.  If your system is NOT
    #  set up to proxy requests to another server, then you can turn proxying
    #  off here.  This will save a small amount of resources on the server.
    #
    #  If you have proxying turned off, and your configuration files say
    #  to proxy a request, then an error message will be logged.
    #
    #  To disable proxying, change the "yes" to "no", and comment the
    #  $INCLUDE line.
    #
    #  allowed values: {no, yes}
    #
    proxy_requests  = {{ ternary "yes" "no" .Values.configuration.proxy.enabled }}
    $INCLUDE proxy.conf


    # CLIENTS CONFIGURATION
    #
    #  Client configuration is defined in "clients.conf".
    #

    #  The 'clients.conf' file contains all of the information from the old
    #  'clients' and 'naslist' configuration files.  We recommend that you
    #  do NOT use 'client's or 'naslist', although they are still
    #  supported.
    #
    #  Anything listed in 'clients.conf' will take precedence over the
    #  information from the old-style configuration files.
    #
    $INCLUDE clients.conf


    # THREAD POOL CONFIGURATION
    #
    #  The thread pool is a long-lived group of threads which
    #  take turns (round-robin) handling any incoming requests.
    #
    #  You probably want to have a few spare threads around,
    #  so that high-load situations can be handled immediately.  If you
    #  don't have any spare threads, then the request handling will
    #  be delayed while a new thread is created, and added to the pool.
    #
    #  You probably don't want too many spare threads around,
    #  otherwise they'll be sitting there taking up resources, and
    #  not doing anything productive.
    #
    #  The numbers given below should be adequate for most situations.
    #
    thread pool {
    	#  Number of servers to start initially --- should be a reasonable
    	#  ballpark figure.
    	start_servers = {{ .Values.configuration.threadPool.startServers }}

    	#  Limit on the total number of servers running.
    	#
    	#  If this limit is ever reached, clients will be LOCKED OUT, so it
    	#  should NOT BE SET TOO LOW.  It is intended mainly as a brake to
    	#  keep a runaway server from taking the system with it as it spirals
    	#  down...
    	#
    	#  You may find that the server is regularly reaching the
    	#  'max_servers' number of threads, and that increasing
    	#  'max_servers' doesn't seem to make much difference.
    	#
    	#  If this is the case, then the problem is MOST LIKELY that
    	#  your back-end databases are taking too long to respond, and
    	#  are preventing the server from responding in a timely manner.
    	#
    	#  The solution is NOT do keep increasing the 'max_servers'
    	#  value, but instead to fix the underlying cause of the
    	#  problem: slow database, or 'hostname_lookups=yes'.
    	#
    	#  For more information, see 'max_request_time', above.
    	#
    	max_servers = {{ .Values.configuration.threadPool.maxServers }}

    	#  Server-pool size regulation.  Rather than making you guess
    	#  how many servers you need, FreeRADIUS dynamically adapts to
    	#  the load it sees, that is, it tries to maintain enough
    	#  servers to handle the current load, plus a few spare
    	#  servers to handle transient load spikes.
    	#
    	#  It does this by periodically checking how many servers are
    	#  waiting for a request.  If there are fewer than
    	#  min_spare_servers, it creates a new spare.  If there are
    	#  more than max_spare_servers, some of the spares die off.
    	#  The default values are probably OK for most sites.
    	#
    	min_spare_servers = {{ .Values.configuration.threadPool.minSpareServers }}
    	max_spare_servers = {{ .Values.configuration.threadPool.maxSpareServers }}

    	#  When the server receives a packet, it places it onto an
    	#  internal queue, where the worker threads (configured above)
    	#  pick it up for processing.  The maximum size of that queue
    	#  is given here.
    	#
    	#  When the queue is full, any new packets will be silently
    	#  discarded.
    	#
    	#  The most common cause of the queue being full is that the
    	#  server is dependent on a slow database, and it has received
    	#  a large "spike" of traffic.  When that happens, there is
    	#  very little you can do other than make sure the server
    	#  receives less traffic, or make sure that the database can
    	#  handle the load.
    	#
    #	max_queue_size = 65536

    	#  Clean up old threads periodically.  For no reason other than
    	#  it might be useful.
    	#
    	#  '0' is a special value meaning 'infinity', or 'the servers never
    	#  exit'
    	max_requests_per_server = 0

    	#  Automatically limit the number of accounting requests.
    	#  This configuration item tracks how many requests per second
    	#  the server can handle.  It does this by tracking the
    	#  packets/s received by the server for processing, and
    	#  comparing that to the packets/s handled by the child
    	#  threads.
    	#

    	#  If the received PPS is larger than the processed PPS, *and*
    	#  the queue is more than half full, then new accounting
    	#  requests are probabilistically discarded.  This lowers the
    	#  number of packets that the server needs to process.  Over
    	#  time, the server will "catch up" with the traffic.
    	#
    	#  Throwing away accounting packets is usually safe and low
    	#  impact.  The NAS will retransmit them in a few seconds, or
    	#  even a few minutes.  Vendors should read RFC 5080 Section 2.2.1
    	#  to see how accounting packets should be retransmitted.  Using
    	#  any other method is likely to cause network meltdowns.
    	#
    	auto_limit_acct = no
    }

    ######################################################################
    #
    #  SNMP notifications.  Uncomment the following line to enable
    #  snmptraps.  Note that you MUST also configure the full path
    #  to the "snmptrap" command in the "trigger.conf" file.
    #
    #$INCLUDE trigger.conf

    # MODULE CONFIGURATION
    #
    #  The names and configuration of each module is located in this section.
    #
    #  After the modules are defined here, they may be referred to by name,
    #  in other sections of this configuration file.
    #
    modules {
    	#
    	#  Each module has a configuration as follows:
    	#
    	#	name [ instance ] {
    	#		config_item = value
    	#		...
    	#	}
    	#
    	#  The 'name' is used to load the 'rlm_name' library
    	#  which implements the functionality of the module.
    	#
    	#  The 'instance' is optional.  To have two different instances
    	#  of a module, it first must be referred to by 'name'.
    	#  The different copies of the module are then created by
    	#  inventing two 'instance' names, e.g. 'instance1' and 'instance2'
    	#
    	#  The instance names can then be used in later configuration
    	#  INSTEAD of the original 'name'.  See the 'radutmp' configuration
    	#  for an example.
    	#

    	#
    	#  Some modules have ordering issues.  e.g. "sqlippool" uses
    	#  the configuration from "sql".  In that case, the "sql"
    	#  module must be read off of disk before the "sqlippool".
    	#  However, the directory inclusion below just reads the
    	#  directory from start to finish.  Which means that the
    	#  modules are read off of disk randomly.
    	#
    	#  You can list individual modules *before* the directory
    	#  inclusion.  Those modules will be loaded first.  Then, when
    	#  the directory is read, those modules will be skipped and
    	#  not read twice.
    	#
    #	$INCLUDE mods-enabled/sql

    	#
    	#  All modules are in ther mods-enabled/ directory.  Files
    	#  matching the regex /[a-zA-Z0-9_.]+/ are read.  The
    	#  modules are initialized ONLY if they are referenced in a
    	#  processing section, such as authorize, authenticate,
    	#  accounting, pre/post-proxy, etc.
    	#
    	$INCLUDE mods-enabled/
    }

    # Instantiation
    #
    #  This section sets the instantiation order of the modules.  listed
    #  here will get started up BEFORE the sections like authorize,
    #  authenticate, etc. get examined.
    #
    #  This section is not strictly needed.  When a section like authorize
    #  refers to a module, the module is automatically loaded and
    #  initialized.  However, some modules may not be listed in any of the
    #  processing sections, so they should be listed here.
    #
    #  Also, listing modules here ensures that you have control over
    #  the order in which they are initialized.  If one module needs
    #  something defined by another module, you can list them in order
    #  here, and ensure that the configuration will be OK.
    #
    #  After the modules listed here have been loaded, all of the modules
    #  in the "mods-enabled" directory will be loaded.  Loading the
    #  "mods-enabled" directory means that unlike Version 2, you usually
    #  don't need to list modules here.
    #
    instantiate {
    	#
    	# We list the counter module here so that it registers
    	# the check_name attribute before any module which sets
    	# it
    #	daily

    	# subsections here can be thought of as "virtual" modules.
    	#
    	# e.g. If you have two redundant SQL servers, and you want to
    	# use them in the authorize and accounting sections, you could
    	# place a "redundant" block in each section, containing the
    	# exact same text.  Or, you could uncomment the following
    	# lines, and list "redundant_sql" in the authorize and
    	# accounting sections.
    	#
    	#  The "virtual" module defined here can also be used with
    	#  dynamic expansions, under a few conditions:
    	#
    	#  * The section is "redundant", or "load-balance", or
    	#    "redundant-load-balance"
    	#  * The section contains modules ONLY, and no sub-sections
    	#  * all modules in the section are using the same rlm_
    	#    driver, e.g. They are all sql, or all ldap, etc.
    	#
    	#  When those conditions are satisfied, the server will
    	#  automatically register a dynamic expansion, using the
    	#  name of the "virtual" module.  In the example below,
    	#  it will be "redundant_sql".  You can then use this expansion
    	#  just like any other:
    	#
    	#	update reply {
    	#		Filter-Id := "%{redundant_sql: ... }"
    	#	}
    	#
    	#  In this example, the expansion is done via module "sql1",
    	#  and if that expansion fails, using module "sql2".
    	#
    	#  For best results, configure the "pool" subsection of the
    	#  module so that "retry_delay" is non-zero.  That will allow
    	#  the redundant block to quickly ignore all "down" SQL
    	#  databases.  If instead we have "retry_delay = 0", then
    	#  every time the redundant block is used, the server will try
    	#  to open a connection to every "down" database, causing
    	#  problems.
    	#
    	#redundant redundant_sql {
    	#	sql1
    	#	sql2
    	#}
    }

    ######################################################################
    #
    #  Policies are virtual modules, similar to those defined in the
    #  "instantiate" section above.
    #
    #  Defining a policy in one of the policy.d files means that it can be
    #  referenced in multiple places as a *name*, rather than as a series of
    #  conditions to match, and actions to take.
    #
    #  Policies are something like subroutines in a normal language, but
    #  they cannot be called recursively. They MUST be defined in order.
    #  If policy A calls policy B, then B MUST be defined before A.
    #
    ######################################################################
    policy {
    	$INCLUDE policy.d/
    }

    ######################################################################
    #
    #	Load virtual servers.
    #
    #	This next $INCLUDE line loads files in the directory that
    #	match the regular expression: /[a-zA-Z0-9_.]+/
    #
    #	It allows you to define new virtual servers simply by placing
    #	a file into the raddb/sites-enabled/ directory.
    #
    $INCLUDE sites-enabled/

    ######################################################################
    #
    #	All of the other configuration sections like "authorize {}",
    #	"authenticate {}", "accounting {}", have been moved to the
    #	the file:
    #
    #		raddb/sites-available/default
    #
    #	This is the "default" virtual server that has the same
    #	configuration as in version 1.0.x and 1.1.x.  The default
    #	installation enables this virtual server.  You should
    #	edit it to create policies for your local site.
    #
    #	For more documentation on virtual servers, see:
    #
    #		raddb/sites-available/README
    #
    ######################################################################
  proxy.conf: |
    #-*- text -*-
    ##
    ## proxy.conf -- proxy radius and realm configuration directives
    ##
    ##	$Id: ac90a273522ed36a100d10dd91c62b99db450689 $

    #######################################################################
    #
    #  Proxy server configuration
    #
    #  This entry controls the servers behaviour towards ALL other servers
    #  to which it sends proxy requests.
    #
    proxy server {
    	#
    	#  Note that as of 2.0, the "synchronous", "retry_delay",
    	#  "retry_count", and "dead_time" have all been deprecated.
    	#  For backwards compatibility, they are are still accepted
    	#  by the server, but they ONLY apply to the old-style realm
    	#  configuration.  i.e. realms with "authhost" and/or "accthost"
    	#  entries.
    	#
    	#  i.e. "retry_delay" and "retry_count" have been replaced
    	#  with per-home-server configuration.  See the "home_server"
    	#  example below for details.
    	#
    	#  i.e. "dead_time" has been replaced with a per-home-server
    	#  "revive_interval".  We strongly recommend that this not
    	#  be used, however.  The new method is much better.

    	#
    	#  In 2.0, the server is always "synchronous", and setting
    	#  "synchronous = no" is impossible.  This simplifies the
    	#  server and increases the stability of the network.
    	#  However, it means that the server (i.e. proxy) NEVER
    	#  originates packets.  It proxies packets ONLY when it receives
    	#  a packet or a re-transmission from the NAS.  If the NAS never
    	#  re-transmits, the proxy never re-transmits, either.  This can
    	#  affect fail-over, where a packet does *not* fail over to a
    	#  second home server.. because the NAS never retransmits the
    	#  packet.
    	#
    	#  If you need to set "synchronous = no", please send a
    	#  message to the list <freeradius-users@lists.freeradius.org>
    	#  explaining why this feature is vital for your network.

    	#
    	#  If a realm exists, but there are no live home servers for
    	#  it, we can fall back to using the "DEFAULT" realm.  This is
    	#  most useful for accounting, where the server can proxy
    	#  accounting requests to home servers, but if they're down,
    	#  use a DEFAULT realm that is LOCAL (i.e. accthost = LOCAL),
    	#  and then store the packets in the "detail" file.  That data
    	#  can be later proxied to the home servers by radrelay, when
    	#  those home servers come back up again.

    	#  Setting this to "yes" may have issues for authentication.
    	#  i.e. If you are proxying for two different ISP's, and then
    	#  act as a general dial-up for Gric.  If one of the first two
    	#  ISP's has their RADIUS server go down, you do NOT want to
    	#  proxy those requests to GRIC.  Instead, you probably want
    	#  to just drop the requests on the floor.  In that case, set
    	#  this value to 'no'.
    	#
    	#  allowed values: {yes, no}
    	#
    	default_fallback = {{ ternary "yes" "no" .Values.configuration.proxy.defaultFallback }}

    	#
    	#  Whether or not we allow dynamic home servers.
    	#
    	#  This setting should be "no" by default.  If set to "yes",
    	#  it can slow the server down, due to mutex locking across
    	#  multiple threads.
    	#
    	#  Dynamic servers will work ONLY with the "directory"
    	#  configuration below.
    	#
    #	dynamic = yes

    	#
    	#  The directory which contains dynamic home servers.  Each
    	#  file in the directory should be a normal "home_server"
    	#  definitions.  This directory does not exist by default.
    	#
    	#  e.g: The content of ${raddbdir}/home_servers/example.com should be:
    	#
    	#	home_server example.com {
    	#		...
    	#	}
    	#
    	#  For complete documentation, please see
    	#
    	#	doc/configuration/dynamic_home_servers.md
    	#
    #	directory = ${raddbdir}/home_servers

    }

    #######################################################################
    #
    #  Configuration for the proxy realms.
    #
    #  As of 2.0, the "realm" configuration has changed.  Instead of
    #  specifying "authhost" and "accthost" in a realm section, the home
    #  servers are specified separately in a "home_server" section.  For
    #  backwards compatibility, you can still use the "authhost" and
    #  "accthost" directives.  If you only have one home server for a
    #  realm, it is easier to use the old-style configuration.
    #
    #  However, if you have multiple servers for a realm, we STRONGLY
    #  suggest moving to the new-style configuration.
    #
    #
    #  Load-balancing and failover between home servers is handled via
    #  a "home_server_pool" section.
    #
    #  Finally, The "realm" section defines the realm, some options, and
    #  indicates which server pool should be used for the realm.
    #
    #  This change means that simple configurations now require multiple
    #  sections to define a realm.  However, complex configurations
    #  are much simpler than before, as multiple realms can share the same
    #  server pool.
    #
    #  That is, realms point to server pools, and server pools point to
    #  home servers.  Multiple realms can point to one server pool.  One
    #  server pool can point to multiple home servers.  Each home server
    #  can appear in one or more pools.
    #
    #  See sites-available/tls for an example of configuring home servers,
    #  pools, and realms with TLS.
    #

    ######################################################################
    #
    #  This section defines a "Home Server" which is another RADIUS
    #  server that gets sent proxied requests.  In earlier versions
    #  of FreeRADIUS, home servers were defined in "realm" sections,
    #  which was awkward.  In 2.0, they have been made independent
    #  from realms, which is better for a number of reasons.
    #
    #  You can proxy to a specific home server by doing:
    #
    #	update control {
    #		Home-Server-Name = "name of home server"
    #	}
    #
    home_server localhost {
    	#
    	#  Home servers can be sent Access-Request packets
    	#  or Accounting-Request packets.
    	#
    	#  Allowed values are:
    	#	auth	  - Handles Access-Request packets
    	#	acct	  - Handles Accounting-Request packets
    	#	auth+acct - Handles Access-Request packets at "port",
    	#		    and Accounting-Request packets at "port + 1"
    	#	coa	  - Handles CoA-Request and Disconnect-Request packets.
    	#		    See also raddb/sites-available/originate-coa
    	type = auth

    	#
    	#  Configure ONE OF the following entries:
    	#
    	#	IPv4 address
    	#
    	ipaddr = 127.0.0.1

    	#	OR IPv6 address
    	# ipv6addr = ::1

    	#	OR virtual server
    	# virtual_server = foo

    	#	Note that while both ipaddr and ipv6addr will accept
    	#	both addresses and host names, we do NOT recommend
    	#	using host names.  When you specify a host name, the
    	#	server has to do a DNS lookup to find the IP address
    	#	of the home server.  If the DNS server is slow or
    	#	unresponsive, it means that FreeRADIUS will NOT be
    	#	able to determine the address, and will therefore NOT
    	#	start.
    	#
    	#	Also, the mapping of host name to address is done ONCE
    	#	when the server starts.  If DNS is later updated to
    	#	change the address, FreeRADIUS will NOT discover that
    	#	until after a re-start, or a HUP.
    	#
    	#	If you specify a virtual_server here, then requests
    	#	will be proxied internally to that virtual server.
    	#	These requests CANNOT be proxied again, however.  The
    	#	intent is to have the local server handle packets
    	#	when all home servers are dead.
    	#
    	#	Requests proxied to a virtual server will be passed
    	#	through the pre-proxy and post-proxy sections, just
    	#	like any other request.  See also the sample "realm"
    	#	configuration, below.
    	#
    	#	None of the rest of the home_server configuration is used
    	#	for the "virtual_server" configuration.

    	#
    	#  The port to which packets are sent.
    	#
    	#  Usually 1812 for type "auth", and  1813 for type "acct".
    	#  Older servers may use 1645 and 1646.
    	#  Use 3799 for type "coa"
    	#
    	port = 1812

    	#
    	#  The transport protocol.
    	#
    	#  If unspecified, defaults to "udp", which is the traditional
    	#  RADIUS transport.  It may also be "tcp", in which case TCP
    	#  will be used to talk to this home server.
    	#
    	#  When home servers are put into pools, the pool can contain
    	#  home servers with both UDP and TCP transports.
    	#
    	#proto = udp

    	#
    	#  The shared secret use to "encrypt" and "sign" packets between
    	#  FreeRADIUS and the home server.
    	#
    	#  The secret can be any string, up to 8k characters in length.
    	#
    	#  Control codes can be entered vi octal encoding,
    	#	e.g. "\101\102" == "AB"
    	#  Quotation marks can be entered by escaping them,
    	#	e.g. "foo\"bar"
    	#  Spaces or other "special" characters can be entered
    	#  by putting quotes around the string.
    	#	e.g. "foo bar"
    	#	     "foo;bar"
    	#
    	secret = testing123

    	############################################################
    	#
    	#  The rest of the configuration items listed here are optional,
    	#  and do not have to appear in every home server definition.
    	#
    	############################################################

    	#
    	#  You can optionally specify the source IP address used when
    	#  proxying requests to this home server.  When the src_ipaddr
    	#  it set, the server will automatically create a proxy
    	#  listener for that IP address.
    	#
    	#  If you specify this field for one home server, you will
    	#  likely need to specify it for ALL home servers.
    	#
    	#  If you don't care about the source IP address, leave this
    	#  entry commented.
    	#
    #	src_ipaddr = 127.0.0.1

    	#
    	#  If the home server does not respond to a request within
    	#  this time, the server marks the request as timed out.
    	#  After "response_timeouts", the home server is marked
    	#  as being "zombie", and "zombie_period" starts.
    	#
    	#  The response window can be a number between 0.001 and 60.000
    	#  Values on the low end are discouraged, as they will likely
    	#  not work due to limitations of operating system timers.
    	#
    	#  The default response window is large because responses may
    	#  be slow, especially when proxying across the Internet.
    	#
    	#  Useful range of values: 5 to 60
    	response_window = 20

    	#
    	#  Start "zombie_period" after this many responses have
    	#  timed out.
    	#
    #	response_timeouts = 1

    	#
    	#  If the home server does not respond to ANY packets during
    	#  the "zombie period", it will be considered to be dead.
    	#
    	#  A home server that is marked "zombie" will be used for
    	#  proxying as a low priority.  If there are live servers,
    	#  they will always be preferred to a zombie.  Requests will
    	#  be proxied to a zombie server ONLY when there are no
    	#  live servers.
    	#
    	#  Any request that is proxied to a home server will continue
    	#  to be sent to that home server until the home server is
    	#  marked dead.  At that point, it will fail over to another
    	#  server, if a live server is available.  If none is available,
    	#  then the "post-proxy-type fail" handler will be called.
    	#
    	#  If "status_check" below is something other than "none", then
    	#  the server will start sending status checks at the start of
    	#  the zombie period.  It will continue sending status checks
    	#  until the home server is marked "alive".
    	#
    	#  Useful range of values: 20 to 120
    	zombie_period = 40

    	############################################################
    	#
    	#  As of 2.0, FreeRADIUS supports RADIUS layer "status
    	#  checks".  These are used by a proxy server to see if a home
    	#  server is alive.
    	#
    	#  These status packets are sent ONLY if the proxying server
    	#  believes that the home server is dead.  They are NOT sent
    	#  if the proxying server believes that the home server is
    	#  alive.  They are NOT sent if the proxying server is not
    	#  proxying packets.
    	#
    	#  If the home server responds to the status check packet,
    	#  then it is marked alive again, and is returned to use.
    	#
    	############################################################

    	#
    	#  Some home servers do not support status checks via the
    	#  Status-Server packet.  Others may not have a "test" user
    	#  configured that can be used to query the server, to see if
    	#  it is alive.  For those servers, we have NO WAY of knowing
    	#  when it becomes alive again.  Therefore, after the server
    	#  has been marked dead, we wait a period of time, and mark
    	#  it alive again, in the hope that it has come back to
    	#  life.
    	#
    	#  If it has NOT come back to life, then FreeRADIUS will wait
    	#  for "zombie_period" before marking it dead again.  During
    	#  the "zombie_period", ALL AUTHENTICATIONS WILL FAIL, because
    	#  the home server is still dead.  There is NOTHING that can
    	#  be done about this, other than to enable the status checks,
    	#  as documented below.
    	#
    	#  e.g. if "zombie_period" is 40 seconds, and "revive_interval"
    	#  is 300 seconds, the for 40 seconds out of every 340, or about
    	#  10% of the time, all authentications will fail.
    	#
    	#  If the "zombie_period" and "revive_interval" configurations
    	#  are set smaller, than it is possible for up to 50% of
    	#  authentications to fail.
    	#
    	#  As a result, we recommend enabling status checks, and
    	#  we do NOT recommend using "revive_interval".
    	#
    	#  The "revive_interval" is used ONLY if the "status_check"
    	#  entry below is "none".  Otherwise, it will not be used,
    	#  and should be deleted.
    	#
    	#  Useful range of values: 10 to 3600
    	revive_interval = 120

    	#
    	#  The proxying server (i.e. this one) can do periodic status
    	#  checks to see if a dead home server has come back alive.
    	#
    	#  If set to "none", then the other configuration items listed
    	#  below are not used, and the "revive_interval" time is used
    	#  instead.
    	#
    	#  If set to "status-server", the Status-Server packets are
    	#  sent.  Many RADIUS servers support Status-Server.  If a
    	#  server does not support it, please contact the server
    	#  vendor and request that they add it. With status-server if
    	#  the home server is marked as a zombie and a status-server
    	#  response is received, it will be immediately marked as live.
    	#
    	#  This prevents spurious failovers in federations such as
    	#  eduroam, where intermediary proxy servers may be functional
    	#  but the servers of a home institution may not be,
    	#
    	#  If set to "request", then Access-Request, or Accounting-Request
    	#  packets are sent, depending on the "type" entry above (auth/acct).
    	#
    	#  Allowed values: none, status-server, request
    	status_check = status-server

    	#
    	#  If the home server does not support Status-Server packets,
    	#  then the server can still send Access-Request or
    	#  Accounting-Request packets, with a pre-defined user name.
    	#
    	#  This practice is NOT recommended, as it may potentially let
    	#  users gain network access by using these "test" accounts!
    	#
    	#  If it is used, we recommend that the home server ALWAYS
    	#  respond to these Access-Request status checks with
    	#  Access-Reject.  The status check just needs an answer, it
    	#  does not need an Access-Accept.
    	#
    	#  For Accounting-Request status checks, only the username
    	#  needs to be set.  The rest of the accounting attribute are
    	#  set to default values.  The home server that receives these
    	#  accounting packets SHOULD NOT treat them like normal user
    	#  accounting packets.  i.e It should probably NOT log them to
    	#  a database.
    	#
    	# username = "test_user_please_reject_me"
    	# password = "this is really secret"

    	#
    	#  Configure the interval between sending status check packets.
    	#
    	#  Setting it too low increases the probability of spurious
    	#  fail-over and fallback attempts.
    	#
    	#  Useful range of values: 6 to 120
    	check_interval = 30

    	#
    	#  Wait "check_timeout" seconds for a reply to a status check
    	#  packet.
    	#
    	check_timeout = 4

    	#
    	#  Configure the number of status checks in a row that the
    	#  home server needs to respond to before it is marked alive.
    	#
    	#  If you want to mark a home server as alive after a short
    	#  time period of being responsive, it is best to use a small
    	#  "check_interval", and a large value for
    	#  "num_answers_to_alive".  Using a long "check_interval" and
    	#  a small number for "num_answers_to_alive" increases the
    	#  probability of spurious fail-over and fallback attempts.
    	#
    	#  Useful range of values: 3 to 10
    	num_answers_to_alive = 3

    	#
    	#  Limit the total number of outstanding packets to the home
    	#  server.
    	#
    	#  if ((#request sent) - (#requests received)) > max_outstanding
    	#	then stop sending more packets to the home server
    	#
    	#  This lets us gracefully fall over when the home server
    	#  is overloaded.
    	max_outstanding = 65536

    	#
    	#  The configuration items in the next sub-section are used ONLY
    	#  when "type = coa".  It is ignored for all other type of home
    	#  servers.
    	#
    	#  See RFC 5080 for the definitions of the following terms.
    	#  RAND is a function (internal to FreeRADIUS) returning
    	#  random numbers between -0.1 and +0.1
    	#
    	#  First Re-transmit occurs after:
    	#
    	#	 RT = IRT + RAND*IRT
    	#
    	#  Subsequent Re-transmits occur after:
    	#
    	#	RT = 2 * RTprev + RAND * RTprev
    	#
    	#  Re-transmits are capped at:
    	#
    	#	if (MRT && (RT > MRT)) RT = MRT + RAND * MRT
    	#
    	#  For a maximum number of attempts: MRC
    	#
    	#  For a maximum (total) period of time: MRD.
    	#
    	coa {
    		# Initial retransmit interval: 1..5
    		irt = 2

    		# Maximum Retransmit Timeout: 1..30 (0 == no maximum)
    		mrt = 16

    		# Maximum Retransmit Count: 1..20 (0 == retransmit forever)
    		mrc = 5

    		# Maximum Retransmit Duration: 5..60
    		mrd = 30
    	}

    	#
    	#  Connection limiting for home servers with "proto = tcp".
    	#
    	#  This section is ignored for other home servers.
    	#
    	limit {
    	      #
    	      #  Limit the number of TCP connections to the home server.
    	      #
    	      #  The default is 16.
    	      #  Setting this to 0 means "no limit"
    	      max_connections = 16

    	      #
    	      #  Limit the total number of requests sent over one
    	      #  TCP connection.  After this number of requests, the
    	      #  connection will be closed.  Any new packets that are
    	      #  proxied to the home server will result in a new TCP
    	      #  connection being made.
    	      #
    	      #  Setting this to 0 means "no limit"
    	      max_requests = 0

    	      #
    	      #  The lifetime, in seconds, of a TCP connection.  After
    	      #  this lifetime, the connection will be closed.
    	      #
    	      #  Setting this to 0 means "forever".
    	      lifetime = 0

    	      #
    	      #  The idle timeout, in seconds, of a TCP connection.
    	      #  If no packets have been sent over the connection for
    	      #  this time, the connection will be closed.
    	      #
    	      #  Setting this to 0 means "no timeout".
    	      idle_timeout = 0
    	}

    }

    {{- range .Values.configuration.proxy.homeServers }}
    home_server {{ .name }} {
        type = {{ .type }}
        {{- if .ipaddr }}
        ipaddr = {{ .ipaddr }}
        {{- else if .ipv6addr }}
        ipv6addr = {{ .ipv6addr }}
        {{- else if .virtualServer }}
        virtual_server = {{ .virtualServer }}
        {{- end }}
        port = {{ .port }}
        proto = {{ .proto }}
        secret = {{ print "$ENV{" (include "freeradius.homeserver.secret.env" .) "}" }}
        {{- if .responseWindow }}
        responseWindow = {{ .responseWindow }}
        {{- end }}
        {{- if .responseTimeouts }}
        response_timeouts = {{ .responseTimeouts }}
        {{- end }}
        {{- if .zombiePeriod }}
        zombie_period = {{ .zombiePeriod }}
        {{- end }}
        {{- if .statusCheck }}
        status-check = {{ .statusCheck }}
        {{- end }}
        {{- if and .reviveInterval (eq .statusCheck "none") }}
        revive_interval = {{ .reviveInterval }}
        {{- end }}
        {{- if eq .statusCheck "status-server" }}
        {{- if .checkInterval }}
        check-interval = {{ .checkInterval }}
        {{- end }}
        {{- if .checkTimeout }}
        check_timeout = {{ .checkTimeout }}
        {{- end }}
        {{- if .numAnswersToAlive }}
        num_answers_to_alive = {{ .numAnswersToAlive }}
        {{- end }}
        {{- end }}
        {{- if .maxOutstanding }}
        max_outstanding = {{ .maxOutstanding }}
        {{- end }}
        {{- if and .coa (eq .type "coa") }}
        coa {
            {{- if .coa.irt }}
            irt = {{ .coa.irt }}
            {{- end }}
            {{- if .coa.mrt }}
            irt = {{ .coa.mrt }}
            {{- end }}
            {{- if .coa.mrc }}
            irt = {{ .coa.mrc }}
            {{- end }}
            {{- if .coa.mrd }}
            irt = {{ .coa.mrd }}
            {{- end }}
        }
        {{- end }}
        {{- if and .limit (eq .proto "tcp") }}
        limit {
            {{- if .limit.maxConnections }}
            max_connections = {{ .limit.maxConnections }}
            {{- end }}
            {{- if .limit.maxRequests }}
            max_requests = {{ .limit.maxRequests }}
            {{- end }}
            {{- if .limit.lifetime }}
            lifetime = {{ .limit.lifetime }}
            {{- end }}
            {{- if .limit.idleTimeout }}
            idle_timeout = {{ .limit.idleTimeout }}
            {{- end }}
        }
        {{- end }}
    }
    {{- end }}

    # Sample virtual home server.
    #
    #
    #home_server virtual.example.com {
    #	    virtual_server = virtual.example.com
    #}

    ######################################################################
    #
    #  This section defines a pool of home servers that is used
    #  for fail-over and load-balancing.  In earlier versions of
    #  FreeRADIUS, fail-over and load-balancing were defined per-realm.
    #  As a result, if a server had 5 home servers, each of which served
    #  the same 10 realms, you would need 50 "realm" entries.
    #
    #  In version 2.0, you would need 5 "home_server" sections,
    #  10 'realm" sections, and one "home_server_pool" section to tie the
    #  two together.
    #
    #  You can proxy to a specific home server pool by doing:
    #
    #	update control {
    #		Home-Server-Pool = "name of pool"
    #	}
    #
    home_server_pool my_auth_failover {
    	#
    	#  The type of this pool controls how home servers are chosen.
    	#
    	#  fail-over - the request is sent to the first live
    	#  	home server in the list.  i.e. If the first home server
    	#	is marked "dead", the second one is chosen, etc.
    	#
    	#  load-balance - the least busy home server is chosen,
    	#	where "least busy" is counted by taking the number of
    	#	requests sent to that home server, and subtracting the
    	#	number of responses received from that home server.
    	#
    	#	If there are two or more servers with the same low
    	#	load, then one of those servers is chosen at random.
    	#	This configuration is most similar to the old
    	#	"round-robin" method, though it is not exactly the same.
    	#
    	#	Note that load balancing does not work well with EAP,
    	#	as EAP requires packets for an EAP conversation to be
    	#	sent to the same home server.  The load balancing method
    	#	does not keep state in between packets, meaning that
    	#	EAP packets for the same conversation may be sent to
    	#	different home servers.  This will prevent EAP from
    	#	working.
    	#
    	#	For non-EAP authentication methods, and for accounting
    	#	packets, we recommend using "load-balance".  It will
    	#	ensure the highest availability for your network.
    	#
    	#  client-balance - the home server is chosen by hashing the
    	#	source IP address of the packet.  If that home server
    	#	is down, the next one in the list is used, just as
    	#	with "fail-over".
    	#
    	#	There is no way of predicting which source IP will map
    	#	to which home server.
    	#
    	#	This configuration is most useful to do simple load
    	#	balancing for EAP sessions, as the EAP session will
    	#	always be sent to the same home server.
    	#
    	#  client-port-balance - the home server is chosen by hashing
    	#	the source IP address and source port of the packet.
    	#	If that home server is down, the next one in the list
    	#	is used, just as with "fail-over".
    	#
    	#	This method provides slightly better load balancing
    	#	for EAP sessions than "client-balance".  However, it
    	#	also means that authentication and accounting packets
    	#	for the same session MAY go to different home servers.
    	#
    	#  keyed-balance - the home server is chosen by hashing (FNV)
    	#	the contents of the Load-Balance-Key attribute from the
    	#	control items.  The  request is then sent to home server
    	#	chosen by taking:
    	#
    	#		server = (hash % num_servers_in_pool).
    	#
    	#	If there is no Load-Balance-Key in the control items,
    	#	the load balancing method is identical to "load-balance".
    	#
    	#	For most non-EAP authentication methods, The User-Name
    	#	attribute provides a good key.  An "unlang" policy can
    	#	be used to copy the User-Name to the Load-Balance-Key
    	#	attribute.  This method may not work for EAP sessions,
    	#	as the User-Name outside of the TLS tunnel is often
    	#	static, e.g. "anonymous@realm".
    	#
    	#
    	#  The default type is fail-over.
    	type = fail-over

    	#
    	#  A virtual_server may be specified here.  If so, the
    	#  "pre-proxy" and "post-proxy" sections are called when
    	#  the request is proxied, and when a response is received.
    	#
    	#  This lets you have one policy for all requests that are proxied
    	#  to a home server.  This policy is completely independent of
    	#  any policies used to receive, or process the request.
    	#
    	#virtual_server = pre_post_proxy_for_pool

    	#
    	#  Next, a list of one or more home servers.  The names
    	#  of the home servers are NOT the hostnames, but the names
    	#  of the sections.  (e.g. home_server foo {...} has name "foo".
    	#
    	#  Note that ALL home servers listed here have to be of the same
    	#  type.  i.e. they all have to be "auth", or they all have to
    	#  be "acct", or the all have to be "auth+acct".
    	#
    	home_server = localhost

    	#  Additional home servers can be listed.
    	#  There is NO LIMIT to the number of home servers that can
    	#  be listed, though using more than 10 or so will become
    	#  difficult to manage.
    	#
    	# home_server = foo.example.com
    	# home_server = bar.example.com
    	# home_server = baz.example.com
    	# home_server = ...


    	#
    	#  If ALL home servers are dead, then this "fallback" home server
    	#  is used.  If set, it takes precedence over any realm-based
    	#  fallback, such as the DEFAULT realm.
    	#
    	#  For reasons of stability, this home server SHOULD be a virtual
    	#  server.  Otherwise, the fallback may itself be dead!
    	#
    	#fallback = virtual.example.com
    }

    {{- range .Values.configuration.proxy.homeServerPools }}
    home_server_pool {{ .name }} {
        type = {{ .type }}
        {{- range .homeServers }}
        home_server = {{ . }}
        {{- end }}
    }
    {{- end }}

    ######################################################################
    #
    #
    #  This section defines a new-style "realm".  Note the in version 2.0,
    #  there are many fewer configuration items than in 1.x for a realm.
    #
    #  Automatic proxying is done via the "realms" module (see "man
    #  rlm_realm").  To manually proxy the request put this entry in the
    #  "users" file:

    #
    #
    #DEFAULT	Proxy-To-Realm := "realm_name"
    #
    #
    realm example.com {
    	#
    	#  Realms point to pools of home servers.
    #
    	#  For authentication, the "auth_pool" configuration item
    	#  should point to a "home_server_pool" that was previously
    	#  defined.  All of the home servers in the "auth_pool" must
    	#  be of type "auth".
    	#
    	#  For accounting, the "acct_pool" configuration item
    	#  should point to a "home_server_pool" that was previously
    	#  defined.  All of the home servers in the "acct_pool" must
    	#  be of type "acct".
    	#
    	#  If you have a "home_server_pool" where all of the home servers
    	#  are of type "auth+acct", you can just use the "pool"
    	#  configuration item, instead of specifying both "auth_pool"
    	#  and "acct_pool".

    	auth_pool = my_auth_failover
    #	acct_pool = acct

    	#  The server can proxy CoA packets based on the Operator-Name
    	#  attribute.  This requires that the "suffix" module be
    	#  listed in the "recv-coa" section.
    	#
    	#  See raddb/sites-available/coa
    	#
    #	coa_pool = name_of_coa_pool

    	#
    	#  Normally, when an incoming User-Name is matched against the
    	#  realm, the realm name is "stripped" off, and the "stripped"
    	#  user name is used to perform matches.
    	#
    	#  e.g. User-Name = "bob@example.com" will result in two new
    	#  attributes being created by the "realms" module:
    	#
    	#	Stripped-User-Name = "bob"
    	#	Realm = "example.com"
    	#
    	#  The Stripped-User-Name is then used as a key in the "users"
    	#  file, for example.
    	#
    	#  If you do not want this to happen, uncomment "nostrip" below.
    	#
    	# nostrip

    	#  There are no more configuration entries for a realm.
    }

    {{- range .Values.configuration.proxy.realms }}
    realm {{ .name }} {
        {{- if .authPool }}
        auth_pool = {{ .authPool }}
        {{- end }}
        {{- if .acctPool }}
        acct_pool = {{ .acctPool }}
        {{- end }}
        {{- if .coaPool }}
        coa_pool = {{ .coaPool }}
        {{- end }}
        {{- if .nostrip }}
        nostrip
        {{- end }}
    }
    {{- end }}

    #
    #  This is a sample entry for iPass.
    #  Note that you have to define "ipass_auth_pool" and
    #  "ipass_acct_pool", along with home_servers for them, too.
    #
    #realm IPASS {
    #	nostrip
    #
    #	auth_pool = ipass_auth_pool
    #	acct_pool = ipass_acct_pool
    #}

    #
    #  This realm is used mainly to cancel proxying.  You can have
    #  the "realm suffix" module configured to proxy all requests for
    #  a realm, and then later cancel the proxying, based on other
    #  configuration.
    #
    #  For example, you want to terminate PEAP or EAP-TTLS locally,
    #  you can add the following to the "users" file:
    #
    #  DEFAULT EAP-Type == PEAP, Proxy-To-Realm := LOCAL
    #
    realm LOCAL {
    	#  If we do not specify a server pool, the realm is LOCAL, and
    	#  requests are not proxied to it.
    }

    #
    #  This realm is for requests which don't have an explicit realm
    #  prefix or suffix.  User names like "bob" will match this one.
    #
    #realm NULL {
    #	authhost	= radius.example.com:1600
    #	accthost	= radius.example.com:1601
    #	secret		= testing123
    #}

    #
    #  This realm is for ALL OTHER requests.
    #
    #realm DEFAULT {
    #	authhost	= radius.example.com:1600
    #	accthost	= radius.example.com:1601
    #	secret		= testing123
    #}


    #  This realm "proxies" requests internally to a virtual server.
    #  The pre-proxy and post-proxy sections are run just as with any
    #  other kind of home server.  The virtual server then receives
    #  the request, and replies, just as with any other packet.
    #
    #  Once proxied internally like this, the request CANNOT be proxied
    #  internally or externally.
    #
    #realm virtual.example.com {
    #	virtual_server = virtual.example.com
    #}
    #

    #
    #  Regular expressions may also be used as realm names.  If these are used,
    #  then the "find matching realm" process is as follows:
    #
    #    1) Look for a non-regex realm with an *exact* match for the name.
    #       If found, it is used in preference to any regex matching realm.
    #
    #    2) Look for a regex realm, in the order that they are listed
    #       in the configuration files.  Any regex match is performed in
    #	a case-insensitive fashion.
    #
    #    3) If no realm is found, return the DEFAULT realm, if any.
    #
    #  The order of the realms matters in step (2).  For example, defining
    #  two realms ".*\.example.net$" and ".*\.test\.example\.net$" will result in
    #  the second realm NEVER matching.  This is because all of the realms
    #  which match the second regex also match the first one.  Since the
    #  first regex matches, it is returned.
    #
    #  The solution is to list the realms in the opposite order,. e.g.
    #  ".*\.test\.example.net$", followed by ".*\.example\.net$".
    #
    #
    #  Some helpful rules:
    #
    #   - always place a '~' character at the start of the realm name.
    #     This signifies that it is a regex match, and not an exact match
    #     for the realm.
    #
    #   - place the regex in double quotes.  This helps the configuration
    #     file parser ignore any "special" characters in the regex.
    #     Yes, this rule is different than the normal "unlang" rules for
    #     regular expressions.  That may be fixed in a future release.
    #
    #   - If you are matching domain names, put a '$' at the end of the regex
    #     that matches the domain name.  This tells the regex matching code
    #     that the realm ENDS with the domain name, so it does not match
    #     realms with the domain name in the middle.  e.g. "~.*\.example\.net"
    #     will match "test.example.netFOO", which is likely not what you want.
    #     Using "~(.*\.)example\.net$" is better.
    #
    #  The more regex realms that are defined, the more time it takes to
    #  process them.  You should define as few regex realms as possible
    #  in order to maximize server performance.
    #
    #realm "~(.*\.)*example\.net$" {
    #      auth_pool = my_auth_failover
    #}
  clients.conf: |
    # -*- text -*-
    ##
    ## clients.conf -- client configuration directives
    ##
    ##	$Id: 60f9f4bf8a32804182e4516ac69ac510d25215d1 $

    #######################################################################
    #
    #  Define RADIUS clients (usually a NAS, Access Point, etc.).

    #
    #  Defines a RADIUS client.
    #
    #  '127.0.0.1' is another name for 'localhost'.  It is enabled by default,
    #  to allow testing of the server after an initial installation.  If you
    #  are not going to be permitting RADIUS queries from localhost, we suggest
    #  that you delete, or comment out, this entry.
    #
    #

    #
    #  Each client has a "short name" that is used to distinguish it from
    #  other clients.
    #
    #  In version 1.x, the string after the word "client" was the IP
    #  address of the client.  In 2.0, the IP address is configured via
    #  the "ipaddr" or "ipv6addr" fields.  For compatibility, the 1.x
    #  format is still accepted.
    #
    client localhost {
    	#  Only *one* of ipaddr, ipv4addr, ipv6addr may be specified for
    	#  a client.
    	#
    	#  ipaddr will accept IPv4 or IPv6 addresses with optional CIDR
    	#  notation '/<mask>' to specify ranges.
    	#
    	#  ipaddr will accept domain names e.g. example.org resolving
    	#  them via DNS.
    	#
    	#  If both A and AAAA records are found, A records will be
    	#  used in preference to AAAA.
    	ipaddr = 127.0.0.1

    	#  Same as ipaddr but allows v4 addresses only. Requires A
    	#  record for domain names.
    #	ipv4addr = *	# any.  127.0.0.1 == localhost

    	#  Same as ipaddr but allows v6 addresses only. Requires AAAA
    	#  record for domain names.
    #	ipv6addr = ::	# any.  ::1 == localhost

    	#
    	#  A note on DNS:  We STRONGLY recommend using IP addresses
    	#  rather than host names.  Using host names means that the
    	#  server will do DNS lookups when it starts, making it
    	#  dependent on DNS.  i.e. If anything goes wrong with DNS,
    	#  the server won't start!
    	#
    	#  The server also looks up the IP address from DNS once, and
    	#  only once, when it starts.  If the DNS record is later
    	#  updated, the server WILL NOT see that update.
    	#

    	#
    	#  The transport protocol.
    	#
    	#  If unspecified, defaults to "udp", which is the traditional
    	#  RADIUS transport.  It may also be "tcp", in which case the
    	#  server will accept connections from this client ONLY over TCP.
    	#
    	proto = *

    	#
    	#  The shared secret use to "encrypt" and "sign" packets between
    	#  the NAS and FreeRADIUS.  You MUST change this secret from the
    	#  default, otherwise it's not a secret any more!
    	#
    	#  The secret can be any string, up to 8k characters in length.
    	#
    	#  Control codes can be entered vi octal encoding,
    	#	e.g. "\101\102" == "AB"
    	#  Quotation marks can be entered by escaping them,
    	#	e.g. "foo\"bar"
    	#
    	#  A note on security:  The security of the RADIUS protocol
    	#  depends COMPLETELY on this secret!  We recommend using a
    	#  shared secret that is composed of:
    	#
    	#	upper case letters
    	#	lower case letters
    	#	numbers
    	#
    	#  And is at LEAST 8 characters long, preferably 16 characters in
    	#  length.  The secret MUST be random, and should not be words,
    	#  phrase, or anything else that is recognisable.
    	#
    	#  The default secret below is only for testing, and should
    	#  not be used in any real environment.
    	#
    	secret = testing123

    	#
    	#  Old-style clients do not send a Message-Authenticator
    	#  in an Access-Request.  RFC 5080 suggests that all clients
    	#  SHOULD include it in an Access-Request.  The configuration
    	#  item below allows the server to require it.  If a client
    	#  is required to include a Message-Authenticator and it does
    	#  not, then the packet will be silently discarded.
    	#
    	#  allowed values: yes, no
    	require_message_authenticator = no

    	#
    	#  The short name is used as an alias for the fully qualified
    	#  domain name, or the IP address.
    	#
    	#  It is accepted for compatibility with 1.x, but it is no
    	#  longer necessary in >= 2.0
    	#
    #	shortname = localhost

    	#
    	# the following three fields are optional, but may be used by
    	# checkrad.pl for simultaneous use checks
    	#

    	#
    	# The nas_type tells 'checkrad.pl' which NAS-specific method to
    	#  use to query the NAS for simultaneous use.
    	#
    	#  Permitted NAS types are:
    	#
    	#	cisco
    	#	computone
    	#	livingston
    	#	juniper
    	#	max40xx
    	#	multitech
    	#	netserver
    	#	pathras
    	#	patton
    	#	portslave
    	#	tc
    	#	usrhiper
    	#	other		# for all other types

    	#
    	nas_type	 = other	# localhost isn't usually a NAS...

    	#
    	#  The following two configurations are for future use.
    	#  The 'naspasswd' file is currently used to store the NAS
    	#  login name and password, which is used by checkrad.pl
    	#  when querying the NAS for simultaneous use.
    	#
    #	login	   = !root
    #	password	= someadminpas

    	#
    	#  As of 2.0, clients can also be tied to a virtual server.
    	#  This is done by setting the "virtual_server" configuration
    	#  item, as in the example below.
    	#
    #	virtual_server = home1

    	#
    	#  A pointer to the "home_server_pool" OR a "home_server"
    	#  section that contains the CoA configuration for this
    	#  client.  For an example of a coa home server or pool,
    	#  see raddb/sites-available/originate-coa
    #	coa_server = coa

    	#
    	#  Response window for proxied packets.  If non-zero,
    	#  then the lower of (home, client) response_window
    	#  will be used.
    	#
    	#  i.e. it can be used to lower the response_window
    	#  packets from one client to a home server.  It cannot
    	#  be used to raise the response_window.
    	#
    #	response_window = 10.0

    	#
    	#  Connection limiting for clients using "proto = tcp".
    	#
    	#  This section is ignored for clients sending UDP traffic
    	#
    	limit {
    		#
    		#  Limit the number of simultaneous TCP connections from a client
    		#
    		#  The default is 16.
    		#  Setting this to 0 means "no limit"
    		max_connections = 16

    		#  The per-socket "max_requests" option does not exist.

    		#
    		#  The lifetime, in seconds, of a TCP connection.  After
    		#  this lifetime, the connection will be closed.
    		#
    		#  Setting this to 0 means "forever".
    		lifetime = 0

    		#
    		#  The idle timeout, in seconds, of a TCP connection.
    		#  If no packets have been received over the connection for
    		#  this time, the connection will be closed.
    		#
    		#  Setting this to 0 means "no timeout".
    		#
    		#  We STRONGLY RECOMMEND that you set an idle timeout.
    		#
    		idle_timeout = 30
    	}
    }

    # IPv6 Client
    client localhost_ipv6 {
    	ipv6addr	= ::1
    	secret		= testing123
    }

    # All IPv6 Site-local clients
    #client sitelocal_ipv6 {
    #	ipv6addr	= fe80::/16
    #	secret		= testing123
    #}

    #client example.org {
    #	ipaddr		= radius.example.org
    #	secret		= testing123
    #}

    #
    #  You can now specify one secret for a network of clients.
    #  When a client request comes in, the BEST match is chosen.
    #  i.e. The entry from the smallest possible network.
    #
    #client private-network-1 {
    #	ipaddr		= 192.0.2.0/24
    #	secret		= testing123-1
    #}

    #client private-network-2 {
    #	ipaddr		= 198.51.100.0/24
    #	secret		= testing123-2
    #}

    #######################################################################
    #
    #  Per-socket client lists.  The configuration entries are exactly
    #  the same as above, but they are nested inside of a section.
    #
    #  You can have as many per-socket client lists as you have "listen"
    #  sections, or you can re-use a list among multiple "listen" sections.
    #
    #  Un-comment this section, and edit a "listen" section to add:
    #  "clients = per_socket_clients".  That IP address/port combination
    #  will then accept ONLY the clients listed in this section.
    #
    #  There are additional considerations when using clients from SQL.
    #
    #  A client can be link to a virtual server via modules such as SQL.
    #  This link is done via the following process:
    #
    #  If there is no listener in a virtual server, SQL clients are added
    #  to the global list for that virtual server.
    #
    #  If there is a listener, and the first listener does not have a
    #  "clients=..." configuration item, SQL clients are added to the
    #  global list.
    #
    #  If there is a listener, and the first one does have a "clients=..."
    #  configuration item, SQL clients are added to that list.  The client
    #  { ...} ` configured in that list are also added for that listener.
    #
    #  The only issue is if you have multiple listeners in a virtual
    #  server, each with a different client list, then the SQL clients are
    #  added only to the first listener.
    #
    #clients per_socket_clients {
    #	client socket_client {
    #		ipaddr = 192.0.2.4
    #		secret = testing123
    #	}
    #}
    {{- range .Values.configuration.clients }}
    client {{ .name }} {
        ipaddr = {{ .ipaddr }}
        {{- if .proto }}
        proto = {{ .proto }}
        {{- end }}
        secret = {{ print "$ENV{" (include "freeradius.client.secret.env" .) "}" }}
        {{- if .requireMessageAuthenticator }}
        require_message_authenticator = {{ ternary "yes" "no" .requireMessageAuthenticator }}
        {{- end }}
        {{- if and .limit (or (eq .proto "tcp") (eq .proto "*")) }}
        limit {
            {{- if .limit.maxConnections }}
            max_connections = {{ .limit.maxConnections }}
            {{- end }}
            {{- if .limit.lifetime }}
            lifetime = {{ .limit.lifetime }}
            {{- end }}
            {{- if .limit.idleTimeout }}
            idle_timeout = {{ .limit.idleTimeout }}
            {{- end }}
        }
        {{- end }}
    }
    {{- end }}
